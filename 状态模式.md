---
title: 状态模式
date: 2019-12-31 16:12:24
disqus: true
---

# 状态模式 State Pattern

**允许一个对象在其内部状态改变时来改变它的行为。**

状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变。

## 初识状态模式

状态模式的关键是把事物的**每种状态都封装成单独的类**，跟此种状态有关的行为都被封装在这个类的内部，只需要在上下文中，把某个请求委托给当前的状态对象即可，该状态对象会负责渲染它自身的行为。同时还可以把状态的切换规则事先分布在状态类中，这样就有效地消除了原本存在的大量条件分支语句。

## 状态模式通用结构

- **上下文Context类**：在这个构造函数内部，初始化每种状态类的实例。`Context` 将持有这些状态对象的引用，以便把请求委托给状态对象。
- **各个状态类：** 将每种状态封装成单独的类，与此状态有关的行为都封装在这个类的内部。

## 实例：开关电灯

**第一步，Context类：**

首先定义了`Ligth`类，`Light`类在这里也被称为上下文(`Context`)。随后在`Light`的构造函数中，我们要创建每一个状态类的实例对象，`Context`将持有这些状态对象的引用，以便把请求委托给状态对象。

```javascript
// Light 类
var Light = function(){
  this.offLightState = new OffLightState(this);
  this.weekLightState = new WeekLightState(this);
  this.strongLightState = new StrongLightState(this);
  this.button = null;
};

Light.prototype.init = function(){
  var button = document.createElement('button');
  var self = this;

  this.button = document.body.appendChild(button);
  this.button.innerHTML = '开关';

  this.currState = this.offLightState;

  this.button.onclick = function(){
    self.currState.buttonWasPressed();
  };
};

Light.prototype.setState = function( newState ){
    this.currState = newState;
};
```

**第二步，封装各个状态类：**

`ligth`对象被传入状态类的构造函数，状态对象也需要持有`ligth`对象的引用，以便调用`ligth`中的方法或者直接操作`light`对象。

在状态类中将定义一些共同的行为方法，Context最终会将请求委托给状态对象的这些方法，在这个例子里，这个方法就是buttonWasPressed。无论增加了多少种状态类，它们都必须实现buttonWasPressed方法。

```javascript
// offLightState
var OffLightState = function(light){
  this.light = light;
};

OffLightState.prototype.buttonWasPressed = function(){
  console.log('弱光') // offLightState 对应的行为
  this.light.setState(this.light.weekLightState); // 切换状态到 weekLightState
};

// WeekLightState
var WeekLightState = function(light){
  this.light = light;
};

WeekLightState.prototype.buttonWasPressed = function(){
  console.log('强光') 
  this.light.setState(this.light.strongLightState);
};

// StrongLightState
var StrongLightState = function(light){
  this.light = light;
};

StrongLightState.prototype.buttonWasPressed = function(){
  console.log('关灯') 
  this.light.setState(this.light.offLightState);
};
```

这里封装了三种状态弱光、强光、关灯，并且每种状态有自己的行为。

Usage:

```javascript
var light = new Light();
light.init(); // offLightState
```

#### 捕获异常：继承抽象父类

JavaScript既不支持抽象类（不能实例化，只有抽象方法），也没有接口的概念。所以在使用状态模式的时候要格外小心，如果编写一个状态子类时，忘记了给这个状态子类实现buttonWasPressed方法，则会在状态切换的时候抛出异常。因为Context总是把请求委托给状态对象的buttonWasPressed方法。所以，要让抽象父类的抽象方法直接抛出一个异常，这个异常至少会在程序运行期间就被发现。

```javascript
// 捕获异常的父类
var State = function(){};
State.prototype.buttonWasPressed = function(){
  throw new Error( '父类的buttonWasPressed 方法必须被重写' );
};

// 示例：给【强光】状态类加异常捕获处理
var SuperStrongLightState = function( light ){
  this.light = light;
};

SuperStrongLightState.prototype = new State(); // 继承抽象父类
SuperStrongLightState.prototype.buttonWasPressed = function(){ // 重写buttonWasPressed 方法
  console.log( '关灯' );
  this.light.setState( this.light.offLightState );
};
```

## 状态模式与策略模式区别

- 相同点

  策略模式和状态模式的相同点是，它们都有一个上下文、一些策略或者状态类，上下文把请求委托给这些类来执行。

- 不同点

  它们之间的区别是策略模式中的各个策略类之间是平等又平行的，它们之间没有任何联系，所以客户必须熟知这些策略类的作用，以便客户随时可以主动切换算法；而在状态模式中，状态和状态对应的行为是早已被封装好的，状态之间的切换也早被规定完成，“改变行为”这件事情在状态内部。
